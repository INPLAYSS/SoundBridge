<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Mobile Client</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.0.1/adapter.min.js"></script>
</head>
<body>
    <h1>WebRTC Mobile Client</h1>
    <button id="startButton">Start Connection</button>
    <audio id="remoteAudio" controls></audio>
    <script>
        const startButton = document.getElementById('startButton');
        const remoteAudio = document.getElementById('remoteAudio');
        const audioContext = new AudioContext({
            latencyHint: 'interactive',
            sampleRate: 48000
        });
        let pc = null;
        let socket = null;

        function playWhenBufferIsFull() {
            if (remoteAudio.readyState >= 2) { // `HAVE_CURRENT_DATA` (2) o mayor indica que hay datos disponibles
                remoteAudio.play().catch(error => {
                    console.error('Error al iniciar la reproducción de audio:', error);
                });
            } else {
                // Si no hay suficientes datos, verifica nuevamente después de un breve retraso
                setTimeout(playWhenBufferIsFull, 100);
            }
        }

        startButton.addEventListener('click', startConnection);

        function startConnection() {
            socket = io('http://192.168.50.112:3000', { 
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 500
        });

            socket.on('connect', () => {
                console.log('Conectado al servidor de señalización');
                socket.emit('phone-connected', socket.id); // Emitir evento de conexión con el ID del socket
            });

            socket.on('disconnect', () => {
                console.log('Desconectado del servidor de señalización');
                // No es necesario emitir 'phone-disconnected' aquí porque el servidor ya detecta la desconexión.
            });

            socket.on('expel', () => {
                alert('Has sido expulsado de la conexión.');
                socket.disconnect();
            });

            socket.on('message', (message) => {
                handleSignalingMessage(message);
            });

            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                iceCandidatePoolSize: 1,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });

            pc.ontrack = (event) => {
                console.log("On track");
                console.log(event.track);
                remoteAudio.srcObject = event.streams[0];
                playWhenBufferIsFull();
            };

            pc.onicecandidate = (event) => {
                if (event.candidate && pc.signalingState === 'stable') {
                    socket.emit('message', { 
                        type: 'ice-candidate', 
                        data: event.candidate
                    });
                }
            };  

            pc.ondatachannel = (event) => {
                const dataChannel = event.channel;
                dataChannel.onmessage = (event) => {
                    console.log('Mensaje en data channel recibido: ' + event.data);
                };
            };
        }

        function handleSignalingMessage(message) {
            const { type, data } = message;

            if (type === 'offer' && pc.signalingState === 'stable') {
                pc.setRemoteDescription(new RTCSessionDescription(data))
                    .then(() => pc.createAnswer())
                    .then((answer) => pc.setLocalDescription(answer))
                    .then(() => socket.emit('message', { type: 'answer', data: pc.localDescription }))
                    .catch((error) => console.error('Error handling offer:', error));
            } else if (type === 'answer' && pc.signalingState === 'have-local-offer') {
                pc.setRemoteDescription(new RTCSessionDescription(data))
                    .catch((error) => console.error('Error handling answer:', error));
            } else if (type === 'ice-candidate') {
                if (data.candidate) {
                    try {
                        const candidate = new RTCIceCandidate(data);
                        pc.addIceCandidate(candidate).catch(e => console.error("Error adding ICE Candidate:", e));
                    } catch (e) {
                        console.error("Error creating ICE Candidate:", e);
                    }
                }
            }
        }
    </script>
</body>
</html>
