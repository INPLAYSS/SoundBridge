<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Mobile Client</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.0.1/adapter.min.js"></script>
</head>
<body>
    <h1>WebRTC Mobile Client</h1>
    <button id="startButton">Start Connection</button>
    <audio id="remoteAudio" controls></audio>
    <script>
        const startButton = document.getElementById('startButton');
        const remoteAudio = document.getElementById('remoteAudio');
        let pc = null;
        let socket = null;

        startButton.addEventListener('click', startConnection);

        function startConnection() {
            socket = io('http://192.168.50.112:3000', { transports: ['websocket'] });

            socket.on('connect', () => {
                console.log('Conectado al servidor de señalización');
                socket.emit('phone-connected', socket.id); // Emitir evento de conexión con el ID del socket
            });

            socket.on('disconnect', () => {
                console.log('Desconectado del servidor de señalización');
                // No es necesario emitir 'phone-disconnected' aquí porque el servidor ya detecta la desconexión.
            });

            socket.on('expel', () => {
                alert('Has sido expulsado de la conexión.');
                socket.disconnect();
            });

            socket.on('message', (message) => {
                handleSignalingMessage(message);
            });

            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.ontrack = (event) => {
                remoteAudio.srcObject = event.streams[0];
            };

            pc.onicecandidate = (event) => {
                if (event.candidate && pc.signalingState === 'stable') {
                    socket.emit('message', { 
                        type: 'ice-candidate', 
                        data: event.candidate
                    });
                }
            };  

            pc.ondatachannel = (event) => {
                const dataChannel = event.channel;
                dataChannel.onmessage = (event) => {
                    console.log('Mensaje en data channel recibido: ' + event.data);
                };
            };
        }

        function handleSignalingMessage(message) {
            const { type, data } = message;

            if (type === 'offer' && pc.signalingState === 'stable') {
                pc.setRemoteDescription(new RTCSessionDescription(data))
                    .then(() => pc.createAnswer())
                    .then((answer) => pc.setLocalDescription(answer))
                    .then(() => socket.emit('message', { type: 'answer', data: pc.localDescription }))
                    .catch((error) => console.error('Error handling offer:', error));
            } else if (type === 'answer' && pc.signalingState === 'have-local-offer') {
                pc.setRemoteDescription(new RTCSessionDescription(data))
                    .catch((error) => console.error('Error handling answer:', error));
            } else if (type === 'ice-candidate') {
                if (data.candidate) {
                    try {
                        const candidate = new RTCIceCandidate(data);
                        pc.addIceCandidate(candidate).catch(e => console.error("Error adding ICE Candidate:", e));
                    } catch (e) {
                        console.error("Error creating ICE Candidate:", e);
                    }
                }
            }
        }
    </script>
</body>
</html>
